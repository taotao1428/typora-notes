# 程序的运行

了解一个程序是如何运行的

## 进程

### 内存映射

程序在执行前会被加载到内存中，下面介绍一下进程的地址空间。

地址空间分为用户空间和内核空间，对于32位操作系统来说，进程拥有4G空间，用户空间大小为3G，内核空间大小为1G。



#### 用户空间

用户空间有下面几个部分组成

| 名称         | 说明                                                         |
| ------------ | ------------------------------------------------------------ |
| text区       | 用于保存代码                                                 |
| data区       | 用于保存已经初始化的全局变量                                 |
| bss区        | 用于保存未初始化的全局变量                                   |
| heap区       | 用于存放代码运行过程中自由分配的变量，c库中的malloc调用就是从该段获取内存空间 |
| memory map区 | 用于内存映射，可以实现内存共享和磁盘映射                     |
| stack        | 栈，程序运行的调用栈                                         |
|              |                                                              |

<img src="/linux/.assert/程序的运行/1556371-20230109150140692-1419721856.png" alt="img" style="zoom:50%;" />

<img src="/linux/.assert/程序的运行/1556371-20230109145253764-324729111.png" alt="img" style="zoom: 67%;" />

![img](/linux/.assert/程序的运行/1556371-20230109150221702-504090956.png)



#### 内核空间

在32位机器中，内核空间大小为1G，内核空间只有内核自己可以访问，用户程序无法访问

![img](/linux/.assert/程序的运行/v2-fd5822fd979cd8a51f1cf24e614a58e7_1440w.jpeg)

由于内核空间只有1G，当物理机内存大于1G时，如果直接映射，内核将最多只能访问1G的物理内存，为了解决该问题，内核空间划分了一部分空间作为**高端内存**，该内存通过动态映射，可以访问所有的物理内存。

在x86结构中，三种类型的区域如下：

**ZONE_DMA** 内存开始的16MB

**ZONE_NORMAL** 16MB~896MB

**ZONE_HIGHMEM** 896MB ~ 结束



### 系统调用，内核态和用户态

为了避免应用程序直接访问硬件，或者做一些危险的操作，用户进程的运行分为内核态和用户态，用户的程序只能运行在用户态，用户态下只能访问虚拟内存，无法直接访问硬件。内核态可以做任何事情，当程序需要访问硬件时，只能通过系统调用，进入内核态。



<img src="/linux/.assert/程序的运行/image-20230319163909643.png" alt="image-20230319163909643" style="zoom:50%;" />



### 子进程

子进程是由进程通过fork等方法创建出来，子进程在刚创建出来时，与父进程的内存空间一致，然后通过调用exec方法，载入新的程序进入内存中，开始执行。

### 线程

对于linux，每个线程对应一个进程，当一个进程需要创建新线程时，其实会创建出一个新进程，但是这个进程与父进程共用一些东西，例如堆内存。对于其他操作系统，线程的实现方式不一样，在创建线程时，只会在进程下，创建一个线程对象，不会创建出一个新进程。



## 操作系统



### 进程调度



### 文件系统





## cpu读取内存

https://zhuanlan.zhihu.com/p/522038503

cpu使用的都是虚拟内存

![img](/linux/.assert/程序的运行/v2-3c5cef96e404de2c843df1a248f1f6dd_1440w.jpeg)

对于多任务操作系统，**每个用户进程都拥有独立的进程地址空间**，也有相应的页表负责虚拟地址到物理地址之间的转换。MMU查询的过程中，用户进程的一级页表的基址存放在TTBR0。**操作系统的内核空间共用一块地址空间**，MMU查询的过程中，内核空间的一级页表基址存放在TTBR1。







![img](/linux/.assert/程序的运行/v2-69ca164b0a714645969a39bbf1f76dcd_r.jpg)